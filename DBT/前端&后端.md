前端翻译：Target -> IR

前端翻译阶段实现对Target指令的解析、对操作码的提取以及根据之灵语义生成对应IR指令序列

前端翻译的核心函数为translator_loop，负责通过while遍历指令并调用translate_insn来逐条翻译，while循环会在达到最大指令数或者遇到跳转时停止
translate_insn是一个函数指针，在不同架构的translate.c文件中被赋值为对应架构的翻译函数
实现将一条具体的目标架构指令转换为中间表示IR

以x86为例，translator_loop中的translate_insn会调用i386_tr_translate_insn，接着再调用disas_insn 函数

disas_insn的作用是反汇编（Disassemble）单条指令，是实际将客户机代码翻译成TCG代码的实现。
它通过一系列的switch case语句，根据不同的指令操作码进行不同的翻译处理

在第一次进行翻译时，i386_tr_tb_start函数为空，意义为初始化代码翻译的准备工作，以确保翻译块能够正确地处理指令。

后端翻译：IR -> Host

后端翻译阶段会根据IR分配Host寄存器、生成Host指令以及对生成的指令进行优化

后端翻译遍历每条IR，通过一系列的switch-case，先根据不同的操作通过tcg_alloc进行分配寄存器，然后调用相应的tcg_out实现将IR翻译成Host的机器码。操作的类型有mov、dup、call和一般操作op。最后返回tcg_current_code_size供tb_gen_code判断翻译是否出错：-1表示缓冲区溢出，应重新分配更大缓存重新生成代码；-2表示生成翻译块过大，应将最大指令数减半重新生成代码。

