# Intro
从本质上说二进制翻译技术也是一种编译技术,它与传统编译器的差别在于其编译处理对象不一样。二进制翻译处理的是某种机器的目标二进制代码,该目标代码是经过传统编译器生成的,经过二进制翻译处理后生成另一种机器的目标二进制代码;而传统编译器处理的是某一种高级语言,经过编译处理生成某种机器的目标代码。

仿照传统编译器前端、中端、后端的划分,二进制翻译在概念上分为前端翻译和后端翻译两个阶段。

# FrontEnd：

Target -> IR

前端解码器根据源机器的指令结构特点,以及可执行文件的格式规定,通过指令模式匹配对二进制可执行码进行处理,反汇编成机器无关的中间表示。

前端翻译阶段实现对Target指令的解析、对操作码的提取以及根据之灵语义生成对应IR指令序列

前端翻译的核心函数为translator_loop，负责通过while遍历指令并调用translate_insn来逐条翻译，while循环会在达到最大指令数或者遇到跳转时停止
translate_insn是一个函数指针，在不同架构的translate.c文件中被赋值为对应架构的翻译函数
实现将一条具体的目标架构指令转换为中间表示IR

以x86为例，translator_loop中的translate_insn会调用i386_tr_translate_insn，接着再调用disas_insn 函数

disas_insn的作用是反汇编（Disassemble）单条指令，是实际将客户机代码翻译成TCG代码的实现。
它通过一系列的switch case语句，根据不同的指令操作码进行不同的翻译处理

在第一次进行翻译时，i386_tr_tb_start函数为空，意义为初始化代码翻译的准备工作，以确保翻译块能够正确地处理指令。

# BackEnd：

IR -> Host

后端优化编码器类似于一般编译器,其功能是从一种中间语言生成优化的目标机代码。它根据目标机器以及目标机器采用的操作系统的特点,将中间表示翻译为目标机器上可执行的二进制代码,综合了常规编译系统中的后端代码优化和生成器,以及类似链接器和装载程序的功能。

后端翻译阶段会根据IR分配Host寄存器、生成Host指令以及对生成的指令进行优化

后端翻译遍历每条IR，通过一系列的switch-case，先根据不同的操作通过tcg_alloc进行分配寄存器，然后调用相应的tcg_out实现将IR翻译成Host的机器码。操作的类型有mov、dup、call和一般操作op。最后返回tcg_current_code_size供tb_gen_code判断翻译是否出错：-1表示缓冲区溢出，应重新分配更大缓存重新生成代码；-2表示生成翻译块过大，应将最大指令数减半重新生成代码。

